"use strict";   




    //ЗАДАНИЕ 1
/* Есть блок-схема https://bit.ly/2OIJXF5 из домашнего задания №5 предыдущего урока.
Решить эту же задачу, используя конструкцию switch...case. Не использовать конструкцию if...else!
*/
let currentUser = prompt("Введите Ваше имя, пожалуйста", "");

switch(currentUser) {

    case "Админ": //после кейсов можно поставить фигурные скобки, это необязательно

        let password = prompt("Ваш пароль, пожалуйста");

        switch(password) {
            case "Чёрный Властелин":
                alert("Добро пожаловать!");
                break;
            case null:
            case "":
                alert("Вход отменен");
                break;
            default:
                alert("Пароль неверен");
        }
        break;

    case null:
    case "":
        alert("Вход отменен");
        break;

    default:
        alert("Я Вас не знаю");
}




        //ЗАДАНИЕ 2
// При помощи цикла for вывести нечетные числа от 1 до 10. Привести как минимум 3 решения.
//1 вариант
for (let someNum = 0; someNum <= 10; someNum++) {
    if (someNum % 2 === 0) {
        continue;
    } else {
        console.log(someNum);
    }
}

//2 вариант
for (let someNum = 0; someNum <= 10; someNum++) {
    if (someNum % 2 !== 0) { //изменения в данной строке, за счет которых можем не писать "continue", код будет короче
        console.log(someNum);
    }
}

//3 вариант
let someNum = 0; // в этом примере взял глобальную переменную
for (someNum; someNum <= 10; someNum++) {
    if (someNum % 2 !== 0) {
        console.log(someNum);  
    }
}

//4 вариант
for (let someNum = 1; someNum <= 10; someNum = someNum + 2) { // самый короткий, но, на мой взгляд, неоптимальный код. Изменил шаг на +2
    console.log(someNum);
}




        //ЗАДАНИЕ 3
/* Переписать код с цикла while на for без изменения поведения цикла:
let i = 0;
while (i < 3) {
    console.log("Номер " + i + "!");
    i++;
}
*/

for (let i = 0; i < 3; i++) {
    console.log("Номер " + i + "!");
}




        //ЗАДАНИЕ 4
/* Написать функцию pow(x, n), которая возвращает x в степени n.
 *  Иначе говоря, умножает x на себя n раз и возвращает результат.
 *  Не использовть оператор возведения в степень **!
 *  Не использововать функцию Math.pow()!
*/
function pow(x, n) {

    let tempResult = x;

    for (let i = 1; i < n; i++) {
        tempResult = tempResult * x;
    } return tempResult;
}

let testPow = pow(2, 10); 
console.log (testPow); //тестим - работает

//2 вариант - через рекурсию (когда функция вызывает сама себя внутри себя (но с другими параметрами) )

//x^n = x * x^(n - 1) - запись по мат.правилам, не по JS
//pow(x, n) === x * pow(x, (n - 1) ); - по правилам JS
//для степени 1
function pow(x, n) {
     return x;
}
//для степени n (больше 1) - здесь действует вложенность функции, детальнее в учебнике есть
function pow(x, n) {
    if (n === 1) {
        return x;
    } else {
        return x * pow(x, n - 1);
    }
}

let test = pow(5, 3);
console.log(test);




        //ЗАДАНИЕ 5
// Написать функцию, определяющую, что число является простым (или не является таковым).
// функция, определяющая, является ли число простым или нет
function getSimpleNum (x) {

    //проверяем, не отменен ли ввод и не введен ли ноль
    if ( isNaN(x) || x === 0) {
        return ("Вы отменили ввод, ввели не число, задали пустое значение или ввели ноль\n\nНоль, кстати, не является простым числом");
    
    //проверяем, целое ли число, ибо изначально тестил эту функцию с числом 10.2 - выдало, что оно простое, но простыми могут быть только целые числа.
    //Прим: JS считает число дробным, если там используется "." между числами, если "," - почему то считает за NaN
    } else if ( !Number.isInteger(x) ) {
        return ("Вы ввели не целое число. Оно не может являться простым");

    //теперь, собственно, главная логика функции
    } else {
        for (let y = 2; y < x; y++) {
        // for (let y = 2; y < x / 2; y++) { - альтернативная строка, проверка идет не до х, а до х/2, ибо нет смысла проверять дальше - все, что дальше половины точно не поделится пополам
            if (x % y === 0) {
                return (`Число ${x} не является простым`);
            }
        } return (`Число ${x} простое`);
    }
} 

let simpleNum = getSimpleNum(17); 
console.log(simpleNum); //тестим... и-и-и - работает


// 5а - Спросить у пользователя какое-нибудь число и ответить ему, простое число ли он ввёл.
let userNum = +prompt("Введите число для проверки, простое ли оно", "");
let userSimpleNum = getSimpleNum( userNum ); /*в этом примере можно было не вводить дополнительную переменную, а 
указать сразу в скобках в параметрах функции +prompt, тогда введенное пользователем число сразу станет параметром "x" для функции*/ 
alert(userSimpleNum);


//5b - С помощью этой функции найти максимальное простое число, не большее 1000000.
function getLastSimpleNum (y) {
    test:
    for (let a = y; a > 2; a--) {
        for (let b = a - 1; b > 2; b--) {
            if (a % b === 0) continue test;
        } return (a);
    }
}

let bigUserNum = getLastSimpleNum(1000000);
console.log(bigUserNum);
// Прим 1: за счет того, что мы идем с конца и нам нужно только самое первое значение, после которого идет return, прерывающий функцию - время исполнения оптимально
// Прим 2: по логике, и здесь можно было бы провести все проверки на NaN, ноль и целые числа (как делал выше), но для легкости чтения не стал загружать однотипным кодом
// Прим 3: эта функция найдет не только наибольшее простое число, не более 1 000 000, но и любое простое число, не более любого указанного значения
// Прим 4: конечно же, можно также внедрить пользовательский ввод prompt для того, чтобы желающий мог ввести любое овер большое число




        //ЗАДАНИЕ 6
/* Мини-игра "Минг Бонг".
 *  Восстал монстр Минг Бонг! Храбрые борцы с монстрами спешат на помощь! Изначально Минг Бонг имеет 50 единиц здоровья.
 *  Каждый ход игры Минг Бонг выпивает магическое зелье, которое ему поставляет в неограниченном
 *  количестве злая колдунья Сардулья. Оно восстанавливает ему некое количество здоровья (вводит пользователь).
 *  Затем борцы с монстрами поливают его из антимонстропушкаруса, и это снимает ему некое количество здоровья
 *  (тоже вводит пользователь, каждый раз заново на каждом ходу). Затем начинается новый ход.
 *  Если в любой миг здоровье Минг Бонга превысит 100, то он поработит мир.
 *  Если в любой миг здоровье Минг Бонга упадет ниже 0, то он умирает, а Сардулья отправляется в тюрьму для злых колдуний.
 *  После того, как игра закончилась с любым исходом, показать статистику игры: кто победил, сколько ходов на это потребовалось,
 *  каков был максимальный нанесенный урон и какое максимальное количество здоровья было восстановлено,
 *  а также зафиксированный минимум и максимум здоровья монстра.
*/

function fight () {

    let mingBong = 50; 
    let badWitch; // переменная для восстановления здоровья
    let warriors; // переменная для урона
    let health = 0; // переменная для нахождения максимального восстановления здоровья
    let damage = 0; // переменная для нахождения максимального урона
    let movesWitch = 0; // переменная для подсчета кол-ва ходов ведьм
    let movesWarriors = 0; // переменная для подсчета кол-ва ходов борцов
    let sumWitch = 0; // переменная для подсчета общего восстановления здоровья от зелья ведьм
    let sumWarriors = 0; // переменная для подсчета общего урона от борцов
    let maxHealth = 50; // переменная для получения последнего максимального здоровья монстра
    let minHealth = 50; // переменная для получения последнего минимального здоровья монстра

    
    while (mingBong > 0 && mingBong < 100) {

        // начинаем с первой части - восстановления здоровья
        badWitch = +prompt("Плюс к здоровью Минг Бонга от зелья кольдуньи", ""); 

        // условие для определения разового максимального восстановления здоровья для статистики
        if (badWitch > health) {
            health = badWitch;
        } else {
            health = health;
        }

        // эта проверка на isNaN оказалась необходимой, ибо без нее при введении не чисел, скрипт падал
        if ( isNaN(badWitch) ) { 
            alert("К сожалению, Вы ввели не число. Вы потеряли ход и он не засчитан.\nПодыгрываете борцам? Отлично )");

        } else {
            // расчет общего восстановления здоровья для статистики
            sumWitch = sumWitch + badWitch; 

            // расчет общего кол-ва ходов ведьм для статистики
            movesWitch = movesWitch + 1; 

            // расчет нового количества здоровья монстра после восстановления
            mingBong = mingBong + badWitch;

            // условие для определения максимального здоровья монстра для статистики
            /* в чате разгорелся спор - какое минимальное и максимальное зафиксированное значение жизни выводить:
            ** которое было до победы/поражения (соответственно, в диапазоне от 0 до 100) или
            ** последнее зафиксированное состояние мин и макс здоровья уже после победы/поражения (соответственно, диапазон неограничен
            и может быть как, например, -1000, так и +1000 и более)
            Если нам нужен первый вариант, то такой код указан сразу ниже и используется как рабочий.
            Если нам нужен второй вариант, то просто убираем "&& (mingBong < 100).
            Аналогично и для кода борцов ниже.
             */
            if ( (maxHealth < mingBong) && (mingBong < 100) ) {
                maxHealth = mingBong;
            } else {
                maxHealth = maxHealth;
            }
            // условие для прекращения игры
            if (mingBong >= 100) {
                // чтобы сделать сразу девять выводов return, оборачиваю их в массив
                return [mingBong, sumWitch, sumWarriors, movesWitch,
                        movesWarriors, health, damage, maxHealth, minHealth];
            }
        }

        //все расчетные параметры для борцов аналогичны предущим (как для ведьм), посему здесь без комментов
        warriors = +prompt("Урон здоровью Минг Бонга", ""); 

        if (warriors > damage) {
            damage = warriors;
        } else {
            damage = damage;
        }

        if ( isNaN(warriors) ) {
            alert("К сожалению, Вы ввели не число. Вы потеряли ход и он не засчитан.\nНеужели подыгрываете монстру?");

        } else {

            sumWarriors = sumWarriors + warriors;

            movesWarriors = movesWarriors + 1;

            mingBong = mingBong - warriors;

            if ( (minHealth > mingBong) && (mingBong > 0) ) {
                minHealth = mingBong;
            } else {
                minHealth = minHealth;
            }

            if (mingBong <= 0) {
                return [mingBong, sumWitch, sumWarriors, movesWitch,
                        movesWarriors, health, damage, maxHealth, minHealth];
            }
        }
    }
}

let combat = fight(); // вызываем функцию и заодно в нее же делаем return массива со значениями

let healthMingBong = combat[0]; // извлекаем из массива итоговое здоровье Минг Бонга
let sumHealth = combat[1]; // извлекаем из массива общее восполнение здоровья
let sumDamage = combat[2]; // извлекаем из массива общий урон
let sumMovesWitches = combat[3]; // извлекаем из массива кол-во ходов ведьм
let sumMovesWarriors = combat[4]; // извлекаем из массива кол-во ходов борцов
let bigHealth = combat[5]; // извлекаем наибольшее полученное значение здоровья
let bigDamage = combat[6]; // извлекаем наибольшее значение нанесенного урона
let lastMaxHealth = combat[7]; // извлекаем последнее максимальное здоровье Минг Бонга
let lastMinHealth = combat[8]; //извлекаем последнее наименьшее здоровье Минг Бонга

//а теперь итоговые выводы
// данные об итоговой победе
if (healthMingBong <= 0) {
    alert ("Поздравляем! Монстр повержен! Хвала борцам!\nКолдунья на святой инквизиции, а зелье занесено в ст.228 УК РФ");
}
if (healthMingBong >= 100) {
    alert ("И проиграли борцы эту битву и наступило на Земле царство монстров и колдуний.\n\nЛавкрафт пляшет");
}

//общая статистика
alert("Общая статистика:\n\n" + 
"* Здоровье монстра на конец игры: " + healthMingBong + 
";\n* Всего восстановлено здоровья: " + sumHealth +
";\n* Всего нанесено урона: " + sumDamage +
";\n* Всего ходов ведьм: " + sumMovesWitches +
";\n* Всего ходов борцов: " + sumMovesWarriors +
";\n* Максимальное разовое восcтановление здоровья: " + bigHealth + 
";\n* Максимальный разовый нанесенный урон: " + bigDamage +
";\n* Последнее максимальное здоровье: " + lastMaxHealth +
";\n* Последнее минимальное здоровье: " + lastMinHealth + ";");

/*
Прим 1: это было интересное и прям эпичное задание, потребовавшее, наверное, несколько десятков исправлений и тестов
Прим 2: не обращайте внимания на, возможно, чрезмерное кол-во комментов - это на первое время, по большей части, для меня самого
Прим 3: можно было бы в конце кода не объявлять новые переменные для данных из массива, а использовать те, которые указаны в начале функции,
но предварительно вытащив их наружу, сделав глобальными - тогда бы просто их значения заменились. Но есть мнение, что заменять значения
глобальных переменных - не комильфо. 
Прим 4: то чувство, когда закончил и всё работает: https://yandex.ru/images/search?text=it%27s%20alive&from=tabbar 
*/
