"use strict";



        //ЗАДАНИЕ 1
/* Написать функцию getMostFrequentNumber(arr), принимающую массив чисел,
  возвращающую строку, состоящую из числа и количества раз, которое оно
  встретилось в массиве.
*/

function getMostFrequentNumber(arr) {

  // переменная для вывода наиболее частовстречающегося числа. Приравниваем к первому аргументу массива для случаев, когда повторов в массиве нет 
  let freaquentNumber = arr[0];

  // переменная для подсчета количества совпадений на один элемент массива arr[i]
  let repeatCounter = 0;

  // переменная для сохранения максимального значения повторений
  let maxRepeat = 1;
  
  for (let i = 0; i < arr.length; i++) {
    for (let j = i; j < arr.length; j++) {

      if (arr[i] === arr[j]) {
        repeatCounter++;
      }

      // проверяем текущее сохраненное в maxRepeat количество повторений и сраниваем с новой итерацией и если счетчик больше, то записываем значение текущего элемента массива   
      if (maxRepeat < repeatCounter) {
        maxRepeat = repeatCounter;
        freaquentNumber = arr[i];
        }
      }

  // после итерации одного цикла i, обнуляем счетчик  
  repeatCounter = 0;
  }

  let msg = `${freaquentNumber} (${maxRepeat} times)`;
  return msg;
}

console.log( getMostFrequentNumber( [1, 1, 1, 1, 2, 3] ) ); // '1 (4 times)'
console.log( getMostFrequentNumber( [1, 5, 3, 3, 1, 5, 5, 5, 1] ) ); // 5 (4 times)
console.log( getMostFrequentNumber( [1] ) ); // '1 (1 times)'
console.log( getMostFrequentNumber( [2, 1] ) ); // '2 (1 times)'
console.log( getMostFrequentNumber( [2, 7, 3, 1, 7] ) ); // '7 (2 times)'
// данный алгоритм сработает даже и не на массивах. Но если нам нужны исключительсно массивы, можем поставить в начале проверку Array.isArray()
console.log( getMostFrequentNumber( "somes" ) ); // s (2 times)




        //ЗАДАНИЕ 2
/* Написать функцию map(fn, arr), принимающую некую функцию и массив.
  Эта функция fn должна обрабатывать каждый элемент массива arr
  и возвращать новый массив
*/
function map(fn, arr) {
    let result = arr.map(fn);
    return result;
} 

const square = x => x * x; // возведение в квадрат
console.log( map( square, [1, 2, 3, 4] ) ); // [1, 4, 9, 16]
        
const reverse = str => str.split('').reverse().join(''); // "переворачиваем" строку
console.log( map( reverse, ['hello', 'world'] ) ); // ['olleh', 'dlrow']
 



        //ЗАДАНИЕ 3
/* Написать функцию getDaysToNewYear(), которая возвращает, сколько дней
  осталось до Нового Года, то есть до 1 января 2020 года 00 ч 00 мин 00 сек.
  Разумеется, число дней должно уменьшаться по мере приближения НГ в зависимости
  от даты вызова этой функции.
*/ 
function getDaysToNewYear() {
    let newYearDate = new Date (2020, 0, 1);
    let currentDate = new Date ();
    let daysTo = Math.floor( (newYearDate - currentDate) / (24 * 60 * 60 * 1000) );
    return daysTo;
}

console.log( getDaysToNewYear() );



        //ЗАДАНИЕ 4
// Не выполняя кода, ответить, что выведет браузер в этих примерах и почему:
if (!("a" in window)) {
  var a = 1;
}
alert(a);
// Ответ: undefined
// Правильный ответ: undefined (объяснение на видео 6 урок)
// Объяснение: Несмотря на то, что "a" объявлена в блоке if, она объявлена как var, значит будет видна снаружи. Но знак отрицания "!" так не считает (тестил и с ним и без него). Полагаю, он указывает, что данная переменная НЕ находится в глобальном объекте
//--------------------------------------------

let b = function a(x) {
  x && a(--x);
};
alert(a); 
// Ответ: Ошибка правильного объявления функции?...
// Правильный ответ: ошибка (объяснение на видео 6 урок)
// Объяснение: Не знаю правильного ответа, ибо объявлена вроде как function expression, но не совсем по правилам - у нее уже есть имя "b", зачем писать еще и "а" после слова "function"?
//--------------------------------------------

function a(x) {
  return x * 2;
}

let a;
alert(a); // 
// Ответ: "а была объявлена ранее" - ошибка
// Правильный ответ: "а была объявлена ранее" - ошибка (объяснение на видео 6 урок)
// Объяснение: 
  // Случай 1: "а" уже присвоено функции и новое декларирование "а" выдаст ошибку
  // Случай 2: в случае, если в объявлении имени ФУНКЦИИ ошибка и на самом деле у функции и переменной разные имена - мы объявляем переменную "а" и сразу вызываем ее. Так как "а" мы просто определили, но не дали ей значение, будет undefined
  // Случай 3: в случае, если в объявлении имени ПЕРЕМЕННОЙ ошибка и на самом деле у функции и переменной разные имена, то логично предположить, что вызов "a" (без скобочек) выдаст нам в консоль (или alert) само тело функции
//--------------------------------------------

function b(x, y, a) {
  arguments[2] = 10;
  alert(a);
}

b(1, 2, 3);
// Ответ: 3
// Правильный ответ: 3 (объяснение на видео 6 урок)
// Объяснение: впервые вижу обращение к аргументам функции через "arguments[2]" - вряд ли это относится к аргументам функции, скорее к некому (необъявленному) массиву или строке "arguments". 
//--------------------------------------------

function a() {
    alert(this);
}

a.call(null); 
// Ответ: null
// Правильный ответ: null (объяснение на видео 6 урок)
// Объяснение: метод .call (синтаксис: function.call(arg1, arg2... argN)), первый ее аргумент (в нашем случае null) передается в функцию как ее this, остальные - "как есть". В данном простом примере я понял решение, но что такое "this" в функции в целом - мне совсем непонятно (исключение: функции конструкторы - там прекрасно понятно для чего нужны this). До воскресения попробую разобраться



        //ЗАДАНИЕ 5
/* Написать функцию создания генератора sequence(start, step). Она при вызове возвращает другую функцию-генератор,
  которая при каждом вызове дает число на step больше, и так до бесконечности.
  Начальное число, с которого начинать отсчет, и шаг, задается при создании генератора.
  Шаг можно не указывать, тогда он будет равен одному. Начальное значение по умолчанию равно 0.
  Генераторов можно создать сколько угодно
*/ 
function sequence(start, step) {

  // вводим новую переменную и присваиваем ей изначальное значение start, чтобы потом новая переменная менялась и возвращалась и могли сравнить с изначальным start 
  let funcIteration = start;

    // ставим проверку на случай, если будет введена новая переменная generator с присвоенной функцией БЕЗ аргументов 
    if ( isNaN(funcIteration) ) {
        funcIteration = 0;
    }

    // проверка для шага, аналогичная проверке начального значения
    if ( isNaN(step) ) {
        step = 1;
    }

    return function generator () {
      
        // учитывая дальнейшую логику, нам шаг с размером 1 никак не подходит, поэтому вынесем его в отдельную логику и она будет крайне проста, через постинкремент
        if (step === 1) {
          return funcIteration++;

        } else {

          // проверяем, первый ли раз вызывается функция. Проверка через сравнение с изначально заданным стартом
          if (funcIteration === start || funcIteration === 0) {
            return funcIteration++; // постинкремент нам нужен, чтобы после возврата начального значения, изменить его для следующей проверки
            
          // эта проверка нужна для понимания, что к нам приходит позиция уже не первого вызова функции, а именно второго вызова, после применения инкремента
          } else if (funcIteration - start === 1 ) {
            funcIteration--; // примененный ранее постинкремент нам далее вовсе не нужен, поэтому убираем его, применяя перед шагом декремент
            funcIteration = funcIteration + step;
            return funcIteration;
          
          // и данная ветка начнет выполнение уже с третьего вызова функции и далее
          } else {
            funcIteration = funcIteration + step;
            return funcIteration;
          }
        }
    };
}

const generator1 = sequence(10, 3);
const generator2 = sequence(7, 1);

console.log( generator1() ); // 10
console.log( generator1() ); // 13

console.log( generator2() ); // 7

console.log( generator1() ); // 16
console.log( generator1() ); // 19

console.log( generator2() ); // 8
console.log( generator2() ); // 9
console.log( generator2() ); // 10

// доп.проверка на функцию без аргументов:
const generator3 = sequence();

console.log( generator3() ); // 0
console.log( generator3() ); // 1
console.log( generator3() ); // 2



        //ЗАДАНИЕ 6
/* Написать функцию take(gen, x), которая вызывает функцию gen заданное число x раз
  и возвращает массив с результатами вызовов
*/
function take (gen, x) {

  // вводим переменную, которая будет массивом для вывода нужных значений
  let resultArr = [];

  for (let i = 0; i < x; i++) {

      // добавляем чрез .push к пустому массиву результат каждого вызова функции
      resultArr.push(gen());
      
    } return resultArr;
}

const gen2 = sequence(0, 2);
console.log( take (gen2, 5) ); // [0, 2, 4, 6, 8]

// P.S. Спасибо за детальные вводные к задачам. Это и правда дает 50% к пониманию решения. Вот бы все клиентские ТЗ были такие ))
